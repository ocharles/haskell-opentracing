{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Sampling_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data SamplingStrategyType = PROBABILISTIC|RATE_LIMITING  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SamplingStrategyType where
  fromEnum t = case t of
    PROBABILISTIC -> 0
    RATE_LIMITING -> 1
  toEnum t = case t of
    0 -> PROBABILISTIC
    1 -> RATE_LIMITING
    _ -> X.throw T.ThriftException
instance H.Hashable SamplingStrategyType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SamplingStrategyType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ProbabilisticSamplingStrategy = ProbabilisticSamplingStrategy  { probabilisticSamplingStrategy_samplingRate :: P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProbabilisticSamplingStrategy where
  hashWithSalt salt record = salt   `H.hashWithSalt` probabilisticSamplingStrategy_samplingRate record  
instance QC.Arbitrary ProbabilisticSamplingStrategy where 
  arbitrary = M.liftM ProbabilisticSamplingStrategy (QC.arbitrary)
  shrink obj | obj == default_ProbabilisticSamplingStrategy = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProbabilisticSamplingStrategy{probabilisticSamplingStrategy_samplingRate = probabilisticSamplingStrategy_samplingRate obj} then P.Nothing else P.Just $ default_ProbabilisticSamplingStrategy{probabilisticSamplingStrategy_samplingRate = probabilisticSamplingStrategy_samplingRate obj}
    ]
from_ProbabilisticSamplingStrategy :: ProbabilisticSamplingStrategy -> T.ThriftVal
from_ProbabilisticSamplingStrategy record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("samplingRate",T.TDouble _v2))) $ probabilisticSamplingStrategy_samplingRate record
  ]
write_ProbabilisticSamplingStrategy :: T.Protocol p => p -> ProbabilisticSamplingStrategy -> P.IO ()
write_ProbabilisticSamplingStrategy oprot record = T.writeVal oprot $ from_ProbabilisticSamplingStrategy record
encode_ProbabilisticSamplingStrategy :: T.StatelessProtocol p => p -> ProbabilisticSamplingStrategy -> LBS.ByteString
encode_ProbabilisticSamplingStrategy oprot record = T.serializeVal oprot $ from_ProbabilisticSamplingStrategy record
to_ProbabilisticSamplingStrategy :: T.ThriftVal -> ProbabilisticSamplingStrategy
to_ProbabilisticSamplingStrategy (T.TStruct fields) = ProbabilisticSamplingStrategy{
  probabilisticSamplingStrategy_samplingRate = P.maybe (P.error "Missing required field: samplingRate") (\(_,_val4) -> (case _val4 of {T.TDouble _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ProbabilisticSamplingStrategy _ = P.error "not a struct"
read_ProbabilisticSamplingStrategy :: T.Protocol p => p -> P.IO ProbabilisticSamplingStrategy
read_ProbabilisticSamplingStrategy iprot = to_ProbabilisticSamplingStrategy <$> T.readVal iprot (T.T_STRUCT typemap_ProbabilisticSamplingStrategy)
decode_ProbabilisticSamplingStrategy :: T.StatelessProtocol p => p -> LBS.ByteString -> ProbabilisticSamplingStrategy
decode_ProbabilisticSamplingStrategy iprot bs = to_ProbabilisticSamplingStrategy $ T.deserializeVal iprot (T.T_STRUCT typemap_ProbabilisticSamplingStrategy) bs
typemap_ProbabilisticSamplingStrategy :: T.TypeMap
typemap_ProbabilisticSamplingStrategy = Map.fromList [(1,("samplingRate",T.T_DOUBLE))]
default_ProbabilisticSamplingStrategy :: ProbabilisticSamplingStrategy
default_ProbabilisticSamplingStrategy = ProbabilisticSamplingStrategy{
  probabilisticSamplingStrategy_samplingRate = 0}
data RateLimitingSamplingStrategy = RateLimitingSamplingStrategy  { rateLimitingSamplingStrategy_maxTracesPerSecond :: I.Int16
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RateLimitingSamplingStrategy where
  hashWithSalt salt record = salt   `H.hashWithSalt` rateLimitingSamplingStrategy_maxTracesPerSecond record  
instance QC.Arbitrary RateLimitingSamplingStrategy where 
  arbitrary = M.liftM RateLimitingSamplingStrategy (QC.arbitrary)
  shrink obj | obj == default_RateLimitingSamplingStrategy = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RateLimitingSamplingStrategy{rateLimitingSamplingStrategy_maxTracesPerSecond = rateLimitingSamplingStrategy_maxTracesPerSecond obj} then P.Nothing else P.Just $ default_RateLimitingSamplingStrategy{rateLimitingSamplingStrategy_maxTracesPerSecond = rateLimitingSamplingStrategy_maxTracesPerSecond obj}
    ]
from_RateLimitingSamplingStrategy :: RateLimitingSamplingStrategy -> T.ThriftVal
from_RateLimitingSamplingStrategy record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8 -> P.Just (1, ("maxTracesPerSecond",T.TI16 _v8))) $ rateLimitingSamplingStrategy_maxTracesPerSecond record
  ]
write_RateLimitingSamplingStrategy :: T.Protocol p => p -> RateLimitingSamplingStrategy -> P.IO ()
write_RateLimitingSamplingStrategy oprot record = T.writeVal oprot $ from_RateLimitingSamplingStrategy record
encode_RateLimitingSamplingStrategy :: T.StatelessProtocol p => p -> RateLimitingSamplingStrategy -> LBS.ByteString
encode_RateLimitingSamplingStrategy oprot record = T.serializeVal oprot $ from_RateLimitingSamplingStrategy record
to_RateLimitingSamplingStrategy :: T.ThriftVal -> RateLimitingSamplingStrategy
to_RateLimitingSamplingStrategy (T.TStruct fields) = RateLimitingSamplingStrategy{
  rateLimitingSamplingStrategy_maxTracesPerSecond = P.maybe (P.error "Missing required field: maxTracesPerSecond") (\(_,_val10) -> (case _val10 of {T.TI16 _val11 -> _val11; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RateLimitingSamplingStrategy _ = P.error "not a struct"
read_RateLimitingSamplingStrategy :: T.Protocol p => p -> P.IO RateLimitingSamplingStrategy
read_RateLimitingSamplingStrategy iprot = to_RateLimitingSamplingStrategy <$> T.readVal iprot (T.T_STRUCT typemap_RateLimitingSamplingStrategy)
decode_RateLimitingSamplingStrategy :: T.StatelessProtocol p => p -> LBS.ByteString -> RateLimitingSamplingStrategy
decode_RateLimitingSamplingStrategy iprot bs = to_RateLimitingSamplingStrategy $ T.deserializeVal iprot (T.T_STRUCT typemap_RateLimitingSamplingStrategy) bs
typemap_RateLimitingSamplingStrategy :: T.TypeMap
typemap_RateLimitingSamplingStrategy = Map.fromList [(1,("maxTracesPerSecond",T.T_I16))]
default_RateLimitingSamplingStrategy :: RateLimitingSamplingStrategy
default_RateLimitingSamplingStrategy = RateLimitingSamplingStrategy{
  rateLimitingSamplingStrategy_maxTracesPerSecond = 0}
data OperationSamplingStrategy = OperationSamplingStrategy  { operationSamplingStrategy_operation :: LT.Text
  , operationSamplingStrategy_probabilisticSampling :: ProbabilisticSamplingStrategy
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OperationSamplingStrategy where
  hashWithSalt salt record = salt   `H.hashWithSalt` operationSamplingStrategy_operation record   `H.hashWithSalt` operationSamplingStrategy_probabilisticSampling record  
instance QC.Arbitrary OperationSamplingStrategy where 
  arbitrary = M.liftM OperationSamplingStrategy (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_OperationSamplingStrategy = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OperationSamplingStrategy{operationSamplingStrategy_operation = operationSamplingStrategy_operation obj} then P.Nothing else P.Just $ default_OperationSamplingStrategy{operationSamplingStrategy_operation = operationSamplingStrategy_operation obj}
    , if obj == default_OperationSamplingStrategy{operationSamplingStrategy_probabilisticSampling = operationSamplingStrategy_probabilisticSampling obj} then P.Nothing else P.Just $ default_OperationSamplingStrategy{operationSamplingStrategy_probabilisticSampling = operationSamplingStrategy_probabilisticSampling obj}
    ]
from_OperationSamplingStrategy :: OperationSamplingStrategy -> T.ThriftVal
from_OperationSamplingStrategy record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v14 -> P.Just (1, ("operation",T.TString $ E.encodeUtf8 _v14))) $ operationSamplingStrategy_operation record
  , (\_v14 -> P.Just (2, ("probabilisticSampling",from_ProbabilisticSamplingStrategy _v14))) $ operationSamplingStrategy_probabilisticSampling record
  ]
write_OperationSamplingStrategy :: T.Protocol p => p -> OperationSamplingStrategy -> P.IO ()
write_OperationSamplingStrategy oprot record = T.writeVal oprot $ from_OperationSamplingStrategy record
encode_OperationSamplingStrategy :: T.StatelessProtocol p => p -> OperationSamplingStrategy -> LBS.ByteString
encode_OperationSamplingStrategy oprot record = T.serializeVal oprot $ from_OperationSamplingStrategy record
to_OperationSamplingStrategy :: T.ThriftVal -> OperationSamplingStrategy
to_OperationSamplingStrategy (T.TStruct fields) = OperationSamplingStrategy{
  operationSamplingStrategy_operation = P.maybe (P.error "Missing required field: operation") (\(_,_val16) -> (case _val16 of {T.TString _val17 -> E.decodeUtf8 _val17; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  operationSamplingStrategy_probabilisticSampling = P.maybe (P.error "Missing required field: probabilisticSampling") (\(_,_val16) -> (case _val16 of {T.TStruct _val18 -> (to_ProbabilisticSamplingStrategy (T.TStruct _val18)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_OperationSamplingStrategy _ = P.error "not a struct"
read_OperationSamplingStrategy :: T.Protocol p => p -> P.IO OperationSamplingStrategy
read_OperationSamplingStrategy iprot = to_OperationSamplingStrategy <$> T.readVal iprot (T.T_STRUCT typemap_OperationSamplingStrategy)
decode_OperationSamplingStrategy :: T.StatelessProtocol p => p -> LBS.ByteString -> OperationSamplingStrategy
decode_OperationSamplingStrategy iprot bs = to_OperationSamplingStrategy $ T.deserializeVal iprot (T.T_STRUCT typemap_OperationSamplingStrategy) bs
typemap_OperationSamplingStrategy :: T.TypeMap
typemap_OperationSamplingStrategy = Map.fromList [(1,("operation",T.T_STRING)),(2,("probabilisticSampling",(T.T_STRUCT typemap_ProbabilisticSamplingStrategy)))]
default_OperationSamplingStrategy :: OperationSamplingStrategy
default_OperationSamplingStrategy = OperationSamplingStrategy{
  operationSamplingStrategy_operation = "",
  operationSamplingStrategy_probabilisticSampling = default_ProbabilisticSamplingStrategy}
data PerOperationSamplingStrategies = PerOperationSamplingStrategies  { perOperationSamplingStrategies_defaultSamplingProbability :: P.Double
  , perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond :: P.Double
  , perOperationSamplingStrategies_perOperationStrategies :: (Vector.Vector OperationSamplingStrategy)
  , perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PerOperationSamplingStrategies where
  hashWithSalt salt record = salt   `H.hashWithSalt` perOperationSamplingStrategies_defaultSamplingProbability record   `H.hashWithSalt` perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond record   `H.hashWithSalt` perOperationSamplingStrategies_perOperationStrategies record   `H.hashWithSalt` perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond record  
instance QC.Arbitrary PerOperationSamplingStrategies where 
  arbitrary = M.liftM PerOperationSamplingStrategies (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_PerOperationSamplingStrategies = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PerOperationSamplingStrategies{perOperationSamplingStrategies_defaultSamplingProbability = perOperationSamplingStrategies_defaultSamplingProbability obj} then P.Nothing else P.Just $ default_PerOperationSamplingStrategies{perOperationSamplingStrategies_defaultSamplingProbability = perOperationSamplingStrategies_defaultSamplingProbability obj}
    , if obj == default_PerOperationSamplingStrategies{perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond = perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond obj} then P.Nothing else P.Just $ default_PerOperationSamplingStrategies{perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond = perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond obj}
    , if obj == default_PerOperationSamplingStrategies{perOperationSamplingStrategies_perOperationStrategies = perOperationSamplingStrategies_perOperationStrategies obj} then P.Nothing else P.Just $ default_PerOperationSamplingStrategies{perOperationSamplingStrategies_perOperationStrategies = perOperationSamplingStrategies_perOperationStrategies obj}
    , if obj == default_PerOperationSamplingStrategies{perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond = perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond obj} then P.Nothing else P.Just $ default_PerOperationSamplingStrategies{perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond = perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond obj}
    ]
from_PerOperationSamplingStrategies :: PerOperationSamplingStrategies -> T.ThriftVal
from_PerOperationSamplingStrategies record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v21 -> P.Just (1, ("defaultSamplingProbability",T.TDouble _v21))) $ perOperationSamplingStrategies_defaultSamplingProbability record
  , (\_v21 -> P.Just (2, ("defaultLowerBoundTracesPerSecond",T.TDouble _v21))) $ perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond record
  , (\_v21 -> P.Just (3, ("perOperationStrategies",T.TList (T.T_STRUCT typemap_OperationSamplingStrategy) $ P.map (\_v23 -> from_OperationSamplingStrategy _v23) $ Vector.toList _v21))) $ perOperationSamplingStrategies_perOperationStrategies record
  , (\_v21 -> (4, ("defaultUpperBoundTracesPerSecond",T.TDouble _v21))) <$> perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond record
  ]
write_PerOperationSamplingStrategies :: T.Protocol p => p -> PerOperationSamplingStrategies -> P.IO ()
write_PerOperationSamplingStrategies oprot record = T.writeVal oprot $ from_PerOperationSamplingStrategies record
encode_PerOperationSamplingStrategies :: T.StatelessProtocol p => p -> PerOperationSamplingStrategies -> LBS.ByteString
encode_PerOperationSamplingStrategies oprot record = T.serializeVal oprot $ from_PerOperationSamplingStrategies record
to_PerOperationSamplingStrategies :: T.ThriftVal -> PerOperationSamplingStrategies
to_PerOperationSamplingStrategies (T.TStruct fields) = PerOperationSamplingStrategies{
  perOperationSamplingStrategies_defaultSamplingProbability = P.maybe (P.error "Missing required field: defaultSamplingProbability") (\(_,_val25) -> (case _val25 of {T.TDouble _val26 -> _val26; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond = P.maybe (P.error "Missing required field: defaultLowerBoundTracesPerSecond") (\(_,_val25) -> (case _val25 of {T.TDouble _val27 -> _val27; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  perOperationSamplingStrategies_perOperationStrategies = P.maybe (P.error "Missing required field: perOperationStrategies") (\(_,_val25) -> (case _val25 of {T.TList _ _val28 -> (Vector.fromList $ P.map (\_v29 -> (case _v29 of {T.TStruct _val30 -> (to_OperationSamplingStrategy (T.TStruct _val30)); _ -> P.error "wrong type"})) _val28); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TDouble _val31 -> _val31; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_PerOperationSamplingStrategies _ = P.error "not a struct"
read_PerOperationSamplingStrategies :: T.Protocol p => p -> P.IO PerOperationSamplingStrategies
read_PerOperationSamplingStrategies iprot = to_PerOperationSamplingStrategies <$> T.readVal iprot (T.T_STRUCT typemap_PerOperationSamplingStrategies)
decode_PerOperationSamplingStrategies :: T.StatelessProtocol p => p -> LBS.ByteString -> PerOperationSamplingStrategies
decode_PerOperationSamplingStrategies iprot bs = to_PerOperationSamplingStrategies $ T.deserializeVal iprot (T.T_STRUCT typemap_PerOperationSamplingStrategies) bs
typemap_PerOperationSamplingStrategies :: T.TypeMap
typemap_PerOperationSamplingStrategies = Map.fromList [(1,("defaultSamplingProbability",T.T_DOUBLE)),(2,("defaultLowerBoundTracesPerSecond",T.T_DOUBLE)),(3,("perOperationStrategies",(T.T_LIST (T.T_STRUCT typemap_OperationSamplingStrategy)))),(4,("defaultUpperBoundTracesPerSecond",T.T_DOUBLE))]
default_PerOperationSamplingStrategies :: PerOperationSamplingStrategies
default_PerOperationSamplingStrategies = PerOperationSamplingStrategies{
  perOperationSamplingStrategies_defaultSamplingProbability = 0,
  perOperationSamplingStrategies_defaultLowerBoundTracesPerSecond = 0,
  perOperationSamplingStrategies_perOperationStrategies = Vector.empty,
  perOperationSamplingStrategies_defaultUpperBoundTracesPerSecond = P.Nothing}
data SamplingStrategyResponse = SamplingStrategyResponse  { samplingStrategyResponse_strategyType :: SamplingStrategyType
  , samplingStrategyResponse_probabilisticSampling :: P.Maybe ProbabilisticSamplingStrategy
  , samplingStrategyResponse_rateLimitingSampling :: P.Maybe RateLimitingSamplingStrategy
  , samplingStrategyResponse_operationSampling :: P.Maybe PerOperationSamplingStrategies
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SamplingStrategyResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` samplingStrategyResponse_strategyType record   `H.hashWithSalt` samplingStrategyResponse_probabilisticSampling record   `H.hashWithSalt` samplingStrategyResponse_rateLimitingSampling record   `H.hashWithSalt` samplingStrategyResponse_operationSampling record  
instance QC.Arbitrary SamplingStrategyResponse where 
  arbitrary = M.liftM SamplingStrategyResponse (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SamplingStrategyResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SamplingStrategyResponse{samplingStrategyResponse_strategyType = samplingStrategyResponse_strategyType obj} then P.Nothing else P.Just $ default_SamplingStrategyResponse{samplingStrategyResponse_strategyType = samplingStrategyResponse_strategyType obj}
    , if obj == default_SamplingStrategyResponse{samplingStrategyResponse_probabilisticSampling = samplingStrategyResponse_probabilisticSampling obj} then P.Nothing else P.Just $ default_SamplingStrategyResponse{samplingStrategyResponse_probabilisticSampling = samplingStrategyResponse_probabilisticSampling obj}
    , if obj == default_SamplingStrategyResponse{samplingStrategyResponse_rateLimitingSampling = samplingStrategyResponse_rateLimitingSampling obj} then P.Nothing else P.Just $ default_SamplingStrategyResponse{samplingStrategyResponse_rateLimitingSampling = samplingStrategyResponse_rateLimitingSampling obj}
    , if obj == default_SamplingStrategyResponse{samplingStrategyResponse_operationSampling = samplingStrategyResponse_operationSampling obj} then P.Nothing else P.Just $ default_SamplingStrategyResponse{samplingStrategyResponse_operationSampling = samplingStrategyResponse_operationSampling obj}
    ]
from_SamplingStrategyResponse :: SamplingStrategyResponse -> T.ThriftVal
from_SamplingStrategyResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v34 -> P.Just (1, ("strategyType",T.TI32 $ P.fromIntegral $ P.fromEnum _v34))) $ samplingStrategyResponse_strategyType record
  , (\_v34 -> (2, ("probabilisticSampling",from_ProbabilisticSamplingStrategy _v34))) <$> samplingStrategyResponse_probabilisticSampling record
  , (\_v34 -> (3, ("rateLimitingSampling",from_RateLimitingSamplingStrategy _v34))) <$> samplingStrategyResponse_rateLimitingSampling record
  , (\_v34 -> (4, ("operationSampling",from_PerOperationSamplingStrategies _v34))) <$> samplingStrategyResponse_operationSampling record
  ]
write_SamplingStrategyResponse :: T.Protocol p => p -> SamplingStrategyResponse -> P.IO ()
write_SamplingStrategyResponse oprot record = T.writeVal oprot $ from_SamplingStrategyResponse record
encode_SamplingStrategyResponse :: T.StatelessProtocol p => p -> SamplingStrategyResponse -> LBS.ByteString
encode_SamplingStrategyResponse oprot record = T.serializeVal oprot $ from_SamplingStrategyResponse record
to_SamplingStrategyResponse :: T.ThriftVal -> SamplingStrategyResponse
to_SamplingStrategyResponse (T.TStruct fields) = SamplingStrategyResponse{
  samplingStrategyResponse_strategyType = P.maybe (P.error "Missing required field: strategyType") (\(_,_val36) -> (case _val36 of {T.TI32 _val37 -> P.toEnum $ P.fromIntegral _val37; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  samplingStrategyResponse_probabilisticSampling = P.maybe (P.Nothing) (\(_,_val36) -> P.Just (case _val36 of {T.TStruct _val38 -> (to_ProbabilisticSamplingStrategy (T.TStruct _val38)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  samplingStrategyResponse_rateLimitingSampling = P.maybe (P.Nothing) (\(_,_val36) -> P.Just (case _val36 of {T.TStruct _val39 -> (to_RateLimitingSamplingStrategy (T.TStruct _val39)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  samplingStrategyResponse_operationSampling = P.maybe (P.Nothing) (\(_,_val36) -> P.Just (case _val36 of {T.TStruct _val40 -> (to_PerOperationSamplingStrategies (T.TStruct _val40)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SamplingStrategyResponse _ = P.error "not a struct"
read_SamplingStrategyResponse :: T.Protocol p => p -> P.IO SamplingStrategyResponse
read_SamplingStrategyResponse iprot = to_SamplingStrategyResponse <$> T.readVal iprot (T.T_STRUCT typemap_SamplingStrategyResponse)
decode_SamplingStrategyResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> SamplingStrategyResponse
decode_SamplingStrategyResponse iprot bs = to_SamplingStrategyResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_SamplingStrategyResponse) bs
typemap_SamplingStrategyResponse :: T.TypeMap
typemap_SamplingStrategyResponse = Map.fromList [(1,("strategyType",T.T_I32)),(2,("probabilisticSampling",(T.T_STRUCT typemap_ProbabilisticSamplingStrategy))),(3,("rateLimitingSampling",(T.T_STRUCT typemap_RateLimitingSamplingStrategy))),(4,("operationSampling",(T.T_STRUCT typemap_PerOperationSamplingStrategies)))]
default_SamplingStrategyResponse :: SamplingStrategyResponse
default_SamplingStrategyResponse = SamplingStrategyResponse{
  samplingStrategyResponse_strategyType = (P.toEnum 0),
  samplingStrategyResponse_probabilisticSampling = P.Nothing,
  samplingStrategyResponse_rateLimitingSampling = P.Nothing,
  samplingStrategyResponse_operationSampling = P.Nothing}
