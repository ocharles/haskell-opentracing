{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module TracedService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Tracetest_Types
import qualified TracedService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data StartTrace_args = StartTrace_args  { startTrace_args_request :: StartTraceRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartTrace_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startTrace_args_request record  
instance QC.Arbitrary StartTrace_args where 
  arbitrary = M.liftM StartTrace_args (QC.arbitrary)
  shrink obj | obj == default_StartTrace_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartTrace_args{startTrace_args_request = startTrace_args_request obj} then P.Nothing else P.Just $ default_StartTrace_args{startTrace_args_request = startTrace_args_request obj}
    ]
from_StartTrace_args :: StartTrace_args -> T.ThriftVal
from_StartTrace_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v45 -> P.Just (1, ("request",from_StartTraceRequest _v45))) $ startTrace_args_request record
  ]
write_StartTrace_args :: T.Protocol p => p -> StartTrace_args -> P.IO ()
write_StartTrace_args oprot record = T.writeVal oprot $ from_StartTrace_args record
encode_StartTrace_args :: T.StatelessProtocol p => p -> StartTrace_args -> LBS.ByteString
encode_StartTrace_args oprot record = T.serializeVal oprot $ from_StartTrace_args record
to_StartTrace_args :: T.ThriftVal -> StartTrace_args
to_StartTrace_args (T.TStruct fields) = StartTrace_args{
  startTrace_args_request = P.maybe (startTrace_args_request default_StartTrace_args) (\(_,_val47) -> (case _val47 of {T.TStruct _val48 -> (to_StartTraceRequest (T.TStruct _val48)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartTrace_args _ = P.error "not a struct"
read_StartTrace_args :: T.Protocol p => p -> P.IO StartTrace_args
read_StartTrace_args iprot = to_StartTrace_args <$> T.readVal iprot (T.T_STRUCT typemap_StartTrace_args)
decode_StartTrace_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StartTrace_args
decode_StartTrace_args iprot bs = to_StartTrace_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartTrace_args) bs
typemap_StartTrace_args :: T.TypeMap
typemap_StartTrace_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_StartTraceRequest)))]
default_StartTrace_args :: StartTrace_args
default_StartTrace_args = StartTrace_args{
  startTrace_args_request = default_StartTraceRequest}
data StartTrace_result = StartTrace_result  { startTrace_result_success :: TraceResponse
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartTrace_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startTrace_result_success record  
instance QC.Arbitrary StartTrace_result where 
  arbitrary = M.liftM StartTrace_result (QC.arbitrary)
  shrink obj | obj == default_StartTrace_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartTrace_result{startTrace_result_success = startTrace_result_success obj} then P.Nothing else P.Just $ default_StartTrace_result{startTrace_result_success = startTrace_result_success obj}
    ]
from_StartTrace_result :: StartTrace_result -> T.ThriftVal
from_StartTrace_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v51 -> P.Just (0, ("success",from_TraceResponse _v51))) $ startTrace_result_success record
  ]
write_StartTrace_result :: T.Protocol p => p -> StartTrace_result -> P.IO ()
write_StartTrace_result oprot record = T.writeVal oprot $ from_StartTrace_result record
encode_StartTrace_result :: T.StatelessProtocol p => p -> StartTrace_result -> LBS.ByteString
encode_StartTrace_result oprot record = T.serializeVal oprot $ from_StartTrace_result record
to_StartTrace_result :: T.ThriftVal -> StartTrace_result
to_StartTrace_result (T.TStruct fields) = StartTrace_result{
  startTrace_result_success = P.maybe (startTrace_result_success default_StartTrace_result) (\(_,_val53) -> (case _val53 of {T.TStruct _val54 -> (to_TraceResponse (T.TStruct _val54)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_StartTrace_result _ = P.error "not a struct"
read_StartTrace_result :: T.Protocol p => p -> P.IO StartTrace_result
read_StartTrace_result iprot = to_StartTrace_result <$> T.readVal iprot (T.T_STRUCT typemap_StartTrace_result)
decode_StartTrace_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StartTrace_result
decode_StartTrace_result iprot bs = to_StartTrace_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartTrace_result) bs
typemap_StartTrace_result :: T.TypeMap
typemap_StartTrace_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TraceResponse)))]
default_StartTrace_result :: StartTrace_result
default_StartTrace_result = StartTrace_result{
  startTrace_result_success = default_TraceResponse}
data JoinTrace_args = JoinTrace_args  { joinTrace_args_request :: JoinTraceRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinTrace_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinTrace_args_request record  
instance QC.Arbitrary JoinTrace_args where 
  arbitrary = M.liftM JoinTrace_args (QC.arbitrary)
  shrink obj | obj == default_JoinTrace_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinTrace_args{joinTrace_args_request = joinTrace_args_request obj} then P.Nothing else P.Just $ default_JoinTrace_args{joinTrace_args_request = joinTrace_args_request obj}
    ]
from_JoinTrace_args :: JoinTrace_args -> T.ThriftVal
from_JoinTrace_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v57 -> P.Just (1, ("request",from_JoinTraceRequest _v57))) $ joinTrace_args_request record
  ]
write_JoinTrace_args :: T.Protocol p => p -> JoinTrace_args -> P.IO ()
write_JoinTrace_args oprot record = T.writeVal oprot $ from_JoinTrace_args record
encode_JoinTrace_args :: T.StatelessProtocol p => p -> JoinTrace_args -> LBS.ByteString
encode_JoinTrace_args oprot record = T.serializeVal oprot $ from_JoinTrace_args record
to_JoinTrace_args :: T.ThriftVal -> JoinTrace_args
to_JoinTrace_args (T.TStruct fields) = JoinTrace_args{
  joinTrace_args_request = P.maybe (joinTrace_args_request default_JoinTrace_args) (\(_,_val59) -> (case _val59 of {T.TStruct _val60 -> (to_JoinTraceRequest (T.TStruct _val60)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_JoinTrace_args _ = P.error "not a struct"
read_JoinTrace_args :: T.Protocol p => p -> P.IO JoinTrace_args
read_JoinTrace_args iprot = to_JoinTrace_args <$> T.readVal iprot (T.T_STRUCT typemap_JoinTrace_args)
decode_JoinTrace_args :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinTrace_args
decode_JoinTrace_args iprot bs = to_JoinTrace_args $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinTrace_args) bs
typemap_JoinTrace_args :: T.TypeMap
typemap_JoinTrace_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_JoinTraceRequest)))]
default_JoinTrace_args :: JoinTrace_args
default_JoinTrace_args = JoinTrace_args{
  joinTrace_args_request = default_JoinTraceRequest}
data JoinTrace_result = JoinTrace_result  { joinTrace_result_success :: TraceResponse
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinTrace_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinTrace_result_success record  
instance QC.Arbitrary JoinTrace_result where 
  arbitrary = M.liftM JoinTrace_result (QC.arbitrary)
  shrink obj | obj == default_JoinTrace_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinTrace_result{joinTrace_result_success = joinTrace_result_success obj} then P.Nothing else P.Just $ default_JoinTrace_result{joinTrace_result_success = joinTrace_result_success obj}
    ]
from_JoinTrace_result :: JoinTrace_result -> T.ThriftVal
from_JoinTrace_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v63 -> P.Just (0, ("success",from_TraceResponse _v63))) $ joinTrace_result_success record
  ]
write_JoinTrace_result :: T.Protocol p => p -> JoinTrace_result -> P.IO ()
write_JoinTrace_result oprot record = T.writeVal oprot $ from_JoinTrace_result record
encode_JoinTrace_result :: T.StatelessProtocol p => p -> JoinTrace_result -> LBS.ByteString
encode_JoinTrace_result oprot record = T.serializeVal oprot $ from_JoinTrace_result record
to_JoinTrace_result :: T.ThriftVal -> JoinTrace_result
to_JoinTrace_result (T.TStruct fields) = JoinTrace_result{
  joinTrace_result_success = P.maybe (joinTrace_result_success default_JoinTrace_result) (\(_,_val65) -> (case _val65 of {T.TStruct _val66 -> (to_TraceResponse (T.TStruct _val66)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_JoinTrace_result _ = P.error "not a struct"
read_JoinTrace_result :: T.Protocol p => p -> P.IO JoinTrace_result
read_JoinTrace_result iprot = to_JoinTrace_result <$> T.readVal iprot (T.T_STRUCT typemap_JoinTrace_result)
decode_JoinTrace_result :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinTrace_result
decode_JoinTrace_result iprot bs = to_JoinTrace_result $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinTrace_result) bs
typemap_JoinTrace_result :: T.TypeMap
typemap_JoinTrace_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TraceResponse)))]
default_JoinTrace_result :: JoinTrace_result
default_JoinTrace_result = JoinTrace_result{
  joinTrace_result_success = default_TraceResponse}
process_startTrace (seqid, iprot, oprot, handler) = do
  args <- read_StartTrace_args iprot
  (X.catch
    (do
      val <- Iface.startTrace handler (startTrace_args_request args)
      let res = default_StartTrace_result{startTrace_result_success = val}
      T.writeMessage oprot ("startTrace", T.M_REPLY, seqid) $
        write_StartTrace_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("startTrace", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_joinTrace (seqid, iprot, oprot, handler) = do
  args <- read_JoinTrace_args iprot
  (X.catch
    (do
      val <- Iface.joinTrace handler (joinTrace_args_request args)
      let res = default_JoinTrace_result{joinTrace_result_success = val}
      T.writeMessage oprot ("joinTrace", T.M_REPLY, seqid) $
        write_JoinTrace_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("joinTrace", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "startTrace" -> process_startTrace (seqid,iprot,oprot,handler)
  "joinTrace" -> process_joinTrace (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
