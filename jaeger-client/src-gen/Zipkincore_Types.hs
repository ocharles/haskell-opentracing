{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Zipkincore_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data AnnotationType = BOOL|BYTES|I16|I32|I64|DOUBLE|STRING  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum AnnotationType where
  fromEnum t = case t of
    BOOL -> 0
    BYTES -> 1
    I16 -> 2
    I32 -> 3
    I64 -> 4
    DOUBLE -> 5
    STRING -> 6
  toEnum t = case t of
    0 -> BOOL
    1 -> BYTES
    2 -> I16
    3 -> I32
    4 -> I64
    5 -> DOUBLE
    6 -> STRING
    _ -> X.throw T.ThriftException
instance H.Hashable AnnotationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary AnnotationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data Endpoint = Endpoint  { endpoint_ipv4 :: I.Int32
  , endpoint_port :: I.Int16
  , endpoint_service_name :: LT.Text
  , endpoint_ipv6 :: P.Maybe LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Endpoint where
  hashWithSalt salt record = salt   `H.hashWithSalt` endpoint_ipv4 record   `H.hashWithSalt` endpoint_port record   `H.hashWithSalt` endpoint_service_name record   `H.hashWithSalt` endpoint_ipv6 record  
instance QC.Arbitrary Endpoint where 
  arbitrary = M.liftM Endpoint (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Endpoint = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Endpoint{endpoint_ipv4 = endpoint_ipv4 obj} then P.Nothing else P.Just $ default_Endpoint{endpoint_ipv4 = endpoint_ipv4 obj}
    , if obj == default_Endpoint{endpoint_port = endpoint_port obj} then P.Nothing else P.Just $ default_Endpoint{endpoint_port = endpoint_port obj}
    , if obj == default_Endpoint{endpoint_service_name = endpoint_service_name obj} then P.Nothing else P.Just $ default_Endpoint{endpoint_service_name = endpoint_service_name obj}
    , if obj == default_Endpoint{endpoint_ipv6 = endpoint_ipv6 obj} then P.Nothing else P.Just $ default_Endpoint{endpoint_ipv6 = endpoint_ipv6 obj}
    ]
from_Endpoint :: Endpoint -> T.ThriftVal
from_Endpoint record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("ipv4",T.TI32 _v2))) $ endpoint_ipv4 record
  , (\_v2 -> P.Just (2, ("port",T.TI16 _v2))) $ endpoint_port record
  , (\_v2 -> P.Just (3, ("service_name",T.TString $ E.encodeUtf8 _v2))) $ endpoint_service_name record
  , (\_v2 -> (4, ("ipv6",T.TBinary _v2))) <$> endpoint_ipv6 record
  ]
write_Endpoint :: T.Protocol p => p -> Endpoint -> P.IO ()
write_Endpoint oprot record = T.writeVal oprot $ from_Endpoint record
encode_Endpoint :: T.StatelessProtocol p => p -> Endpoint -> LBS.ByteString
encode_Endpoint oprot record = T.serializeVal oprot $ from_Endpoint record
to_Endpoint :: T.ThriftVal -> Endpoint
to_Endpoint (T.TStruct fields) = Endpoint{
  endpoint_ipv4 = P.maybe (endpoint_ipv4 default_Endpoint) (\(_,_val4) -> (case _val4 of {T.TI32 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  endpoint_port = P.maybe (endpoint_port default_Endpoint) (\(_,_val4) -> (case _val4 of {T.TI16 _val6 -> _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  endpoint_service_name = P.maybe (endpoint_service_name default_Endpoint) (\(_,_val4) -> (case _val4 of {T.TString _val7 -> E.decodeUtf8 _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  endpoint_ipv6 = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TBinary _val8 -> _val8; T.TString _val8 -> _val8; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Endpoint _ = P.error "not a struct"
read_Endpoint :: T.Protocol p => p -> P.IO Endpoint
read_Endpoint iprot = to_Endpoint <$> T.readVal iprot (T.T_STRUCT typemap_Endpoint)
decode_Endpoint :: T.StatelessProtocol p => p -> LBS.ByteString -> Endpoint
decode_Endpoint iprot bs = to_Endpoint $ T.deserializeVal iprot (T.T_STRUCT typemap_Endpoint) bs
typemap_Endpoint :: T.TypeMap
typemap_Endpoint = Map.fromList [(1,("ipv4",T.T_I32)),(2,("port",T.T_I16)),(3,("service_name",T.T_STRING)),(4,("ipv6",T.T_BINARY))]
default_Endpoint :: Endpoint
default_Endpoint = Endpoint{
  endpoint_ipv4 = 0,
  endpoint_port = 0,
  endpoint_service_name = "",
  endpoint_ipv6 = P.Nothing}
data Annotation = Annotation  { annotation_timestamp :: I.Int64
  , annotation_value :: LT.Text
  , annotation_host :: P.Maybe Endpoint
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Annotation where
  hashWithSalt salt record = salt   `H.hashWithSalt` annotation_timestamp record   `H.hashWithSalt` annotation_value record   `H.hashWithSalt` annotation_host record  
instance QC.Arbitrary Annotation where 
  arbitrary = M.liftM Annotation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Annotation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Annotation{annotation_timestamp = annotation_timestamp obj} then P.Nothing else P.Just $ default_Annotation{annotation_timestamp = annotation_timestamp obj}
    , if obj == default_Annotation{annotation_value = annotation_value obj} then P.Nothing else P.Just $ default_Annotation{annotation_value = annotation_value obj}
    , if obj == default_Annotation{annotation_host = annotation_host obj} then P.Nothing else P.Just $ default_Annotation{annotation_host = annotation_host obj}
    ]
from_Annotation :: Annotation -> T.ThriftVal
from_Annotation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11 -> P.Just (1, ("timestamp",T.TI64 _v11))) $ annotation_timestamp record
  , (\_v11 -> P.Just (2, ("value",T.TString $ E.encodeUtf8 _v11))) $ annotation_value record
  , (\_v11 -> (3, ("host",from_Endpoint _v11))) <$> annotation_host record
  ]
write_Annotation :: T.Protocol p => p -> Annotation -> P.IO ()
write_Annotation oprot record = T.writeVal oprot $ from_Annotation record
encode_Annotation :: T.StatelessProtocol p => p -> Annotation -> LBS.ByteString
encode_Annotation oprot record = T.serializeVal oprot $ from_Annotation record
to_Annotation :: T.ThriftVal -> Annotation
to_Annotation (T.TStruct fields) = Annotation{
  annotation_timestamp = P.maybe (annotation_timestamp default_Annotation) (\(_,_val13) -> (case _val13 of {T.TI64 _val14 -> _val14; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  annotation_value = P.maybe (annotation_value default_Annotation) (\(_,_val13) -> (case _val13 of {T.TString _val15 -> E.decodeUtf8 _val15; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  annotation_host = P.maybe (P.Nothing) (\(_,_val13) -> P.Just (case _val13 of {T.TStruct _val16 -> (to_Endpoint (T.TStruct _val16)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Annotation _ = P.error "not a struct"
read_Annotation :: T.Protocol p => p -> P.IO Annotation
read_Annotation iprot = to_Annotation <$> T.readVal iprot (T.T_STRUCT typemap_Annotation)
decode_Annotation :: T.StatelessProtocol p => p -> LBS.ByteString -> Annotation
decode_Annotation iprot bs = to_Annotation $ T.deserializeVal iprot (T.T_STRUCT typemap_Annotation) bs
typemap_Annotation :: T.TypeMap
typemap_Annotation = Map.fromList [(1,("timestamp",T.T_I64)),(2,("value",T.T_STRING)),(3,("host",(T.T_STRUCT typemap_Endpoint)))]
default_Annotation :: Annotation
default_Annotation = Annotation{
  annotation_timestamp = 0,
  annotation_value = "",
  annotation_host = P.Nothing}
data BinaryAnnotation = BinaryAnnotation  { binaryAnnotation_key :: LT.Text
  , binaryAnnotation_value :: LBS.ByteString
  , binaryAnnotation_annotation_type :: AnnotationType
  , binaryAnnotation_host :: P.Maybe Endpoint
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BinaryAnnotation where
  hashWithSalt salt record = salt   `H.hashWithSalt` binaryAnnotation_key record   `H.hashWithSalt` binaryAnnotation_value record   `H.hashWithSalt` binaryAnnotation_annotation_type record   `H.hashWithSalt` binaryAnnotation_host record  
instance QC.Arbitrary BinaryAnnotation where 
  arbitrary = M.liftM BinaryAnnotation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BinaryAnnotation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BinaryAnnotation{binaryAnnotation_key = binaryAnnotation_key obj} then P.Nothing else P.Just $ default_BinaryAnnotation{binaryAnnotation_key = binaryAnnotation_key obj}
    , if obj == default_BinaryAnnotation{binaryAnnotation_value = binaryAnnotation_value obj} then P.Nothing else P.Just $ default_BinaryAnnotation{binaryAnnotation_value = binaryAnnotation_value obj}
    , if obj == default_BinaryAnnotation{binaryAnnotation_annotation_type = binaryAnnotation_annotation_type obj} then P.Nothing else P.Just $ default_BinaryAnnotation{binaryAnnotation_annotation_type = binaryAnnotation_annotation_type obj}
    , if obj == default_BinaryAnnotation{binaryAnnotation_host = binaryAnnotation_host obj} then P.Nothing else P.Just $ default_BinaryAnnotation{binaryAnnotation_host = binaryAnnotation_host obj}
    ]
from_BinaryAnnotation :: BinaryAnnotation -> T.ThriftVal
from_BinaryAnnotation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v19 -> P.Just (1, ("key",T.TString $ E.encodeUtf8 _v19))) $ binaryAnnotation_key record
  , (\_v19 -> P.Just (2, ("value",T.TBinary _v19))) $ binaryAnnotation_value record
  , (\_v19 -> P.Just (3, ("annotation_type",T.TI32 $ P.fromIntegral $ P.fromEnum _v19))) $ binaryAnnotation_annotation_type record
  , (\_v19 -> (4, ("host",from_Endpoint _v19))) <$> binaryAnnotation_host record
  ]
write_BinaryAnnotation :: T.Protocol p => p -> BinaryAnnotation -> P.IO ()
write_BinaryAnnotation oprot record = T.writeVal oprot $ from_BinaryAnnotation record
encode_BinaryAnnotation :: T.StatelessProtocol p => p -> BinaryAnnotation -> LBS.ByteString
encode_BinaryAnnotation oprot record = T.serializeVal oprot $ from_BinaryAnnotation record
to_BinaryAnnotation :: T.ThriftVal -> BinaryAnnotation
to_BinaryAnnotation (T.TStruct fields) = BinaryAnnotation{
  binaryAnnotation_key = P.maybe (binaryAnnotation_key default_BinaryAnnotation) (\(_,_val21) -> (case _val21 of {T.TString _val22 -> E.decodeUtf8 _val22; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  binaryAnnotation_value = P.maybe (binaryAnnotation_value default_BinaryAnnotation) (\(_,_val21) -> (case _val21 of {T.TBinary _val23 -> _val23; T.TString _val23 -> _val23; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  binaryAnnotation_annotation_type = P.maybe (binaryAnnotation_annotation_type default_BinaryAnnotation) (\(_,_val21) -> (case _val21 of {T.TI32 _val24 -> P.toEnum $ P.fromIntegral _val24; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  binaryAnnotation_host = P.maybe (P.Nothing) (\(_,_val21) -> P.Just (case _val21 of {T.TStruct _val25 -> (to_Endpoint (T.TStruct _val25)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_BinaryAnnotation _ = P.error "not a struct"
read_BinaryAnnotation :: T.Protocol p => p -> P.IO BinaryAnnotation
read_BinaryAnnotation iprot = to_BinaryAnnotation <$> T.readVal iprot (T.T_STRUCT typemap_BinaryAnnotation)
decode_BinaryAnnotation :: T.StatelessProtocol p => p -> LBS.ByteString -> BinaryAnnotation
decode_BinaryAnnotation iprot bs = to_BinaryAnnotation $ T.deserializeVal iprot (T.T_STRUCT typemap_BinaryAnnotation) bs
typemap_BinaryAnnotation :: T.TypeMap
typemap_BinaryAnnotation = Map.fromList [(1,("key",T.T_STRING)),(2,("value",T.T_BINARY)),(3,("annotation_type",T.T_I32)),(4,("host",(T.T_STRUCT typemap_Endpoint)))]
default_BinaryAnnotation :: BinaryAnnotation
default_BinaryAnnotation = BinaryAnnotation{
  binaryAnnotation_key = "",
  binaryAnnotation_value = "",
  binaryAnnotation_annotation_type = (P.toEnum 0),
  binaryAnnotation_host = P.Nothing}
data Span = Span  { span_trace_id :: I.Int64
  , span_name :: LT.Text
  , span_id :: I.Int64
  , span_parent_id :: P.Maybe I.Int64
  , span_annotations :: (Vector.Vector Annotation)
  , span_binary_annotations :: (Vector.Vector BinaryAnnotation)
  , span_debug :: P.Maybe P.Bool
  , span_timestamp :: P.Maybe I.Int64
  , span_duration :: P.Maybe I.Int64
  , span_trace_id_high :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Span where
  hashWithSalt salt record = salt   `H.hashWithSalt` span_trace_id record   `H.hashWithSalt` span_name record   `H.hashWithSalt` span_id record   `H.hashWithSalt` span_parent_id record   `H.hashWithSalt` span_annotations record   `H.hashWithSalt` span_binary_annotations record   `H.hashWithSalt` span_debug record   `H.hashWithSalt` span_timestamp record   `H.hashWithSalt` span_duration record   `H.hashWithSalt` span_trace_id_high record  
instance QC.Arbitrary Span where 
  arbitrary = M.liftM Span (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Span = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Span{span_trace_id = span_trace_id obj} then P.Nothing else P.Just $ default_Span{span_trace_id = span_trace_id obj}
    , if obj == default_Span{span_name = span_name obj} then P.Nothing else P.Just $ default_Span{span_name = span_name obj}
    , if obj == default_Span{span_id = span_id obj} then P.Nothing else P.Just $ default_Span{span_id = span_id obj}
    , if obj == default_Span{span_parent_id = span_parent_id obj} then P.Nothing else P.Just $ default_Span{span_parent_id = span_parent_id obj}
    , if obj == default_Span{span_annotations = span_annotations obj} then P.Nothing else P.Just $ default_Span{span_annotations = span_annotations obj}
    , if obj == default_Span{span_binary_annotations = span_binary_annotations obj} then P.Nothing else P.Just $ default_Span{span_binary_annotations = span_binary_annotations obj}
    , if obj == default_Span{span_debug = span_debug obj} then P.Nothing else P.Just $ default_Span{span_debug = span_debug obj}
    , if obj == default_Span{span_timestamp = span_timestamp obj} then P.Nothing else P.Just $ default_Span{span_timestamp = span_timestamp obj}
    , if obj == default_Span{span_duration = span_duration obj} then P.Nothing else P.Just $ default_Span{span_duration = span_duration obj}
    , if obj == default_Span{span_trace_id_high = span_trace_id_high obj} then P.Nothing else P.Just $ default_Span{span_trace_id_high = span_trace_id_high obj}
    ]
from_Span :: Span -> T.ThriftVal
from_Span record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v28 -> P.Just (1, ("trace_id",T.TI64 _v28))) $ span_trace_id record
  , (\_v28 -> P.Just (3, ("name",T.TString $ E.encodeUtf8 _v28))) $ span_name record
  , (\_v28 -> P.Just (4, ("id",T.TI64 _v28))) $ span_id record
  , (\_v28 -> (5, ("parent_id",T.TI64 _v28))) <$> span_parent_id record
  , (\_v28 -> P.Just (6, ("annotations",T.TList (T.T_STRUCT typemap_Annotation) $ P.map (\_v30 -> from_Annotation _v30) $ Vector.toList _v28))) $ span_annotations record
  , (\_v28 -> P.Just (8, ("binary_annotations",T.TList (T.T_STRUCT typemap_BinaryAnnotation) $ P.map (\_v32 -> from_BinaryAnnotation _v32) $ Vector.toList _v28))) $ span_binary_annotations record
  , (\_v28 -> (9, ("debug",T.TBool _v28))) <$> span_debug record
  , (\_v28 -> (10, ("timestamp",T.TI64 _v28))) <$> span_timestamp record
  , (\_v28 -> (11, ("duration",T.TI64 _v28))) <$> span_duration record
  , (\_v28 -> (12, ("trace_id_high",T.TI64 _v28))) <$> span_trace_id_high record
  ]
write_Span :: T.Protocol p => p -> Span -> P.IO ()
write_Span oprot record = T.writeVal oprot $ from_Span record
encode_Span :: T.StatelessProtocol p => p -> Span -> LBS.ByteString
encode_Span oprot record = T.serializeVal oprot $ from_Span record
to_Span :: T.ThriftVal -> Span
to_Span (T.TStruct fields) = Span{
  span_trace_id = P.maybe (span_trace_id default_Span) (\(_,_val34) -> (case _val34 of {T.TI64 _val35 -> _val35; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  span_name = P.maybe (span_name default_Span) (\(_,_val34) -> (case _val34 of {T.TString _val36 -> E.decodeUtf8 _val36; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  span_id = P.maybe (span_id default_Span) (\(_,_val34) -> (case _val34 of {T.TI64 _val37 -> _val37; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  span_parent_id = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TI64 _val38 -> _val38; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  span_annotations = P.maybe (span_annotations default_Span) (\(_,_val34) -> (case _val34 of {T.TList _ _val39 -> (Vector.fromList $ P.map (\_v40 -> (case _v40 of {T.TStruct _val41 -> (to_Annotation (T.TStruct _val41)); _ -> P.error "wrong type"})) _val39); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  span_binary_annotations = P.maybe (span_binary_annotations default_Span) (\(_,_val34) -> (case _val34 of {T.TList _ _val42 -> (Vector.fromList $ P.map (\_v43 -> (case _v43 of {T.TStruct _val44 -> (to_BinaryAnnotation (T.TStruct _val44)); _ -> P.error "wrong type"})) _val42); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  span_debug = P.maybe (span_debug default_Span) (\(_,_val34) -> P.Just (case _val34 of {T.TBool _val45 -> _val45; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  span_timestamp = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TI64 _val46 -> _val46; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  span_duration = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TI64 _val47 -> _val47; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  span_trace_id_high = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TI64 _val48 -> _val48; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_Span _ = P.error "not a struct"
read_Span :: T.Protocol p => p -> P.IO Span
read_Span iprot = to_Span <$> T.readVal iprot (T.T_STRUCT typemap_Span)
decode_Span :: T.StatelessProtocol p => p -> LBS.ByteString -> Span
decode_Span iprot bs = to_Span $ T.deserializeVal iprot (T.T_STRUCT typemap_Span) bs
typemap_Span :: T.TypeMap
typemap_Span = Map.fromList [(1,("trace_id",T.T_I64)),(3,("name",T.T_STRING)),(4,("id",T.T_I64)),(5,("parent_id",T.T_I64)),(6,("annotations",(T.T_LIST (T.T_STRUCT typemap_Annotation)))),(8,("binary_annotations",(T.T_LIST (T.T_STRUCT typemap_BinaryAnnotation)))),(9,("debug",T.T_BOOL)),(10,("timestamp",T.T_I64)),(11,("duration",T.T_I64)),(12,("trace_id_high",T.T_I64))]
default_Span :: Span
default_Span = Span{
  span_trace_id = 0,
  span_name = "",
  span_id = 0,
  span_parent_id = P.Nothing,
  span_annotations = Vector.empty,
  span_binary_annotations = Vector.empty,
  span_debug = P.Just P.False,
  span_timestamp = P.Nothing,
  span_duration = P.Nothing,
  span_trace_id_high = P.Nothing}
data Response = Response  { response_ok :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Response where
  hashWithSalt salt record = salt   `H.hashWithSalt` response_ok record  
instance QC.Arbitrary Response where 
  arbitrary = M.liftM Response (QC.arbitrary)
  shrink obj | obj == default_Response = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Response{response_ok = response_ok obj} then P.Nothing else P.Just $ default_Response{response_ok = response_ok obj}
    ]
from_Response :: Response -> T.ThriftVal
from_Response record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v51 -> P.Just (1, ("ok",T.TBool _v51))) $ response_ok record
  ]
write_Response :: T.Protocol p => p -> Response -> P.IO ()
write_Response oprot record = T.writeVal oprot $ from_Response record
encode_Response :: T.StatelessProtocol p => p -> Response -> LBS.ByteString
encode_Response oprot record = T.serializeVal oprot $ from_Response record
to_Response :: T.ThriftVal -> Response
to_Response (T.TStruct fields) = Response{
  response_ok = P.maybe (P.error "Missing required field: ok") (\(_,_val53) -> (case _val53 of {T.TBool _val54 -> _val54; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Response _ = P.error "not a struct"
read_Response :: T.Protocol p => p -> P.IO Response
read_Response iprot = to_Response <$> T.readVal iprot (T.T_STRUCT typemap_Response)
decode_Response :: T.StatelessProtocol p => p -> LBS.ByteString -> Response
decode_Response iprot bs = to_Response $ T.deserializeVal iprot (T.T_STRUCT typemap_Response) bs
typemap_Response :: T.TypeMap
typemap_Response = Map.fromList [(1,("ok",T.T_BOOL))]
default_Response :: Response
default_Response = Response{
  response_ok = P.False}
